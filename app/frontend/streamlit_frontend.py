#!/usr/bin/env python3
"""
üöÄ Agno Teams - Frontend Streamlit

Interface web simples que consome o playground backend existente.
Usa os endpoints corretos do Agno Playground.

Uso:
streamlit run streamlit_frontend.py
"""

import streamlit as st
import requests
import json
import pandas as pd
import numpy as np  # Adicionar import expl√≠cito do numpy
import io
import time
from typing import Optional, Dict, Any, List
import logging

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="üß† Agno Teams",
    page_icon="üß†",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configura√ß√µes
BACKEND_URL = "http://localhost:7777"

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_session_state():
    """Inicializa estado da sess√£o"""
    if "messages" not in st.session_state:
        st.session_state.messages = []
    if "uploaded_file_data" not in st.session_state:
        st.session_state.uploaded_file_data = None
    if "selected_team_id" not in st.session_state:
        st.session_state.selected_team_id = None
    if "session_id" not in st.session_state:
        st.session_state.session_id = None

def check_backend_health():
    """Verifica se o backend est√° rodando usando endpoint correto"""
    try:
        response = requests.get(f"{BACKEND_URL}/v1/playground/status", timeout=5)
        return response.status_code == 200
    except:
        return False

def get_teams():
    """Busca lista de teams dispon√≠veis"""
    try:
        response = requests.get(f"{BACKEND_URL}/v1/playground/teams", timeout=10)
        if response.status_code == 200:
            return response.json()
        return []
    except Exception as e:
        logger.error(f"Erro ao buscar teams: {e}")
        return []

def send_message_to_team(message: str, team_id: str, file_content: Optional[str] = None):
    """Envia mensagem para um team espec√≠fico"""
    try:
        enhanced_message = message
        
        # Se h√° arquivo anexado, processar conforme o tipo
        if file_content:
            try:
                import json
                # Tentar carregar como JSON estruturado (novos uploads)
                file_data = json.loads(file_content)
                filename = file_data.get('filename', 'arquivo')
                file_type = file_data.get('type', 'unknown')
                
                if file_type == 'csv':
                    enhanced_message = f"{message}\n\nüìä **Arquivo CSV anexado**: {filename}\n```csv\n{file_data['content'][:2000]}...\n```\n\nPor favor, analise este dataset CSV completo."
                
                elif file_type == 'pdf':
                    enhanced_message = f"{message}\n\nüìÑ **Arquivo PDF anexado**: {filename}\n[Conte√∫do em Base64 - {file_data['size']} bytes]\n\nPor favor, extraia e analise o texto deste PDF."
                
                elif file_type in ['xls', 'xlsx']:
                    enhanced_message = f"{message}\n\nüìä **Planilha Excel anexada**: {filename}\n[Arquivo {file_type.upper()} em Base64 - {file_data['size']} bytes]\n\nPor favor, processe esta planilha e analise os dados."
                
            except (json.JSONDecodeError, KeyError):
                # Fallback para uploads antigos (texto simples)
                enhanced_message = f"{message}\n\nArquivo CSV carregado para an√°lise:\n```csv\n{file_content[:2000]}...\n```"
        
        # Preparar dados da execu√ß√£o usando multipart/form-data (formato correto da API)
        files = {
            'message': (None, enhanced_message),
            'stream': (None, 'false')  # Desabilitar streaming para interface mais simples
        }
        
        # Enviar para o team espec√≠fico usando endpoint correto
        try:
            response = requests.post(
                f"{BACKEND_URL}/v1/playground/teams/{team_id}/runs",
                files=files,
                timeout=180  # Aumentado para 3 minutos
            )
            
            if response.status_code == 200:
                result = response.json()
                # Verificar se √© um evento completo ou lista de eventos
                if isinstance(result, dict):
                    # Evento √∫nico - extrair conte√∫do
                    content = result.get("content", str(result))
                    return {"response": content}
                elif isinstance(result, list):
                    # Lista de eventos - concatenar conte√∫dos
                    full_content = ""
                    for event in result:
                        if event.get("content"):
                            full_content += event["content"]
                    return {"response": full_content}
                else:
                    return {"response": str(result)}
            else:
                return {"error": f"Erro do servidor: {response.status_code} - {response.text}"}
                
        except requests.exceptions.Timeout:
            return {
                "error": "‚è±Ô∏è **Timeout** - A resposta est√° demorando mais que o esperado. "
                        "Isso pode acontecer com an√°lises complexas. "
                        "Tente novamente com uma pergunta mais espec√≠fica ou aguarde um momento."
            }
        except requests.exceptions.ConnectionError:
            return {
                "error": "üîå **Conex√£o perdida** - Verifique se o backend est√° rodando na porta 7777."
            }
        except Exception as e:
            return {
                "error": f"‚ùå **Erro inesperado**: {str(e)}"
            }
            
    except Exception as e:
        logger.error(f"Erro ao processar mensagem: {e}")
        return {"error": f"Erro de processamento: {str(e)}"}

def render_sidebar():
    """Renderiza sidebar com informa√ß√µes e upload"""
    with st.sidebar:
        st.title("üß† Agno Teams")
        st.markdown("Sistema inteligente de agentes especializados")
        
        # Status do backend
        if check_backend_health():
            st.success("‚úÖ Backend conectado")
        else:
            st.error("‚ùå Backend offline")
            st.warning("Execute o backend primeiro:")
            st.code("python agno_teams_playground.py")
            return False
        
        st.markdown("---")
        
        # Sele√ß√£o de team
        st.subheader("üéØ Selecionar Team")
        teams = get_teams()
        
        if teams:
            # Criar lista de op√ß√µes para o selectbox
            team_options = []
            team_mapping = {}
            
            for team in teams:
                team_name = team.get("name", "Team sem nome")
                team_id = team.get("team_id", "")  # Usar 'team_id' em vez de 'id'
                team_options.append(team_name)
                team_mapping[team_name] = team_id
            
            # Selectbox para escolher team
            selected_team_name = st.selectbox(
                "Escolha um team:",
                ["Auto (Primeiro dispon√≠vel)"] + team_options,
                index=0
            )
            
            if selected_team_name == "Auto (Primeiro dispon√≠vel)":
                st.session_state.selected_team_id = teams[0].get("team_id") if teams else None  # Usar 'team_id'
                st.info("üîÑ Usando o primeiro team dispon√≠vel")
            else:
                st.session_state.selected_team_id = team_mapping[selected_team_name]
                st.info(f"üéØ Team selecionado: {selected_team_name}")
            
            # Mostrar detalhes do team selecionado
            if st.session_state.selected_team_id:
                selected_team = next((t for t in teams if t.get("team_id") == st.session_state.selected_team_id), None)  # Usar 'team_id'
                if selected_team:
                    with st.expander("üìã Detalhes do Team"):
                        st.write(f"**ID**: {selected_team.get('team_id')}")  # Usar 'team_id'
                        st.write(f"**Nome**: {selected_team.get('name')}")
                        if selected_team.get('description'):
                            st.write(f"**Descri√ß√£o**: {selected_team.get('description')}")
                        # Mostrar n√∫mero de membros se dispon√≠vel
                        if selected_team.get('members'):
                            st.write(f"**Membros**: {len(selected_team.get('members'))} agentes especialistas")
        else:
            st.warning("Nenhum team dispon√≠vel")
            return False
        
        st.markdown("---")
        
        # Upload de arquivo
        st.subheader("üìÅ Upload de Dados")
        uploaded_file = st.file_uploader(
            "Arraste e solte um arquivo para an√°lise",
            type=['csv', 'pdf', 'xls', 'xlsx'],
            help="Fa√ßa upload de CSV, PDF, Excel (XLS/XLSX) para an√°lise pelos especialistas"
        )
        
        if uploaded_file is not None:
            try:
                # Detectar tipo de arquivo
                file_extension = uploaded_file.name.lower().split('.')[-1]
                st.info(f"üì§ Processando arquivo {file_extension.upper()}...")
                
                file_content = None
                
                if file_extension == 'csv':
                    # Processar CSV (m√©todo ultra-simples)
                    file_bytes = uploaded_file.read()
                    
                    # Tentar decodificar
                    for encoding in ['utf-8', 'latin-1', 'cp1252']:
                        try:
                            file_content = file_bytes.decode(encoding)
                            break
                        except UnicodeDecodeError:
                            continue
                    
                    if file_content is None:
                        st.error("‚ùå N√£o foi poss√≠vel ler o arquivo CSV")
                        st.session_state.uploaded_file_data = None
                        return True
                    
                    # Contar linhas b√°sico
                    lines = file_content.strip().split('\n')
                    data_lines = lines[1:] if len(lines) > 1 else []
                    
                    st.success(f"‚úÖ CSV carregado: {uploaded_file.name}")
                    st.info(f"üìä {len(data_lines)} linhas de dados")
                
                elif file_extension == 'pdf':
                    # Processar PDF - enviar como base64 para o backend
                    import base64
                    
                    file_bytes = uploaded_file.read()
                    file_content = base64.b64encode(file_bytes).decode('utf-8')
                    
                    st.success(f"‚úÖ PDF carregado: {uploaded_file.name}")
                    st.info(f"ÔøΩ {len(file_bytes)} bytes - PDF ser√° extra√≠do pelo backend")
                    
                elif file_extension in ['xls', 'xlsx']:
                    # Processar Excel - enviar como base64 para o backend
                    import base64
                    
                    file_bytes = uploaded_file.read()
                    file_content = base64.b64encode(file_bytes).decode('utf-8')
                    
                    st.success(f"‚úÖ Excel carregado: {uploaded_file.name}")
                    st.info(f"üìä {len(file_bytes)} bytes - Excel ser√° processado pelo backend")
                
                else:
                    st.error("‚ùå Formato de arquivo n√£o suportado")
                    st.session_state.uploaded_file_data = None
                    return True
                
                # Preview b√°sico
                with st.expander("üëÄ Informa√ß√µes do arquivo"):
                    st.write(f"**Nome**: {uploaded_file.name}")
                    st.write(f"**Tipo**: {file_extension.upper()}")
                    st.write(f"**Tamanho**: {uploaded_file.size} bytes")
                    
                    if file_extension == 'csv' and file_content:
                        # Preview para CSV
                        lines = file_content.strip().split('\n')
                        st.text("Primeiras linhas do CSV:")
                        for i, line in enumerate(lines[:6]):
                            st.text(f"L{i+1}: {line[:80]}{'...' if len(line) > 80 else ''}")
                    
                    elif file_extension == 'pdf':
                        st.info("üìÑ PDF ser√° extra√≠do e analisado pelos agentes")
                        st.text("Conte√∫do: Texto ser√° extra√≠do automaticamente")
                    
                    elif file_extension in ['xls', 'xlsx']:
                        st.info("üìä Planilha ser√° processada pelos agentes de dados")
                        st.text("Conte√∫do: Tabelas e dados ser√£o extra√≠dos automaticamente")
                
                # Preparar dados para envio
                if file_content:
                    # Limitar tamanho se muito grande (especialmente para CSV)
                    if file_extension == 'csv' and len(file_content) > 30000:
                        lines = file_content.strip().split('\n')
                        sample_lines = lines[:100]
                        file_content = '\n'.join(sample_lines)
                        st.warning("‚ö†Ô∏è CSV muito grande. Usando amostra de 100 linhas.")
                    
                    # Criar estrutura de dados com tipo de arquivo
                    upload_data = {
                        "content": file_content,
                        "filename": uploaded_file.name,
                        "type": file_extension,
                        "size": uploaded_file.size
                    }
                    
                    # Converter para string JSON para compatibilidade
                    import json
                    st.session_state.uploaded_file_data = json.dumps(upload_data)
                    st.success("‚úÖ Arquivo pronto para an√°lise!")
                
            except Exception as e:
                st.error(f"‚ùå Erro ao processar {file_extension.upper()}: {e}")
                st.session_state.uploaded_file_data = None
        else:
            st.session_state.uploaded_file_data = None
        
        st.markdown("---")
        
        # Exemplos de perguntas
        st.subheader("üí° Exemplos de Perguntas")
        with st.expander("üìä An√°lise de Dados (CSV/Excel)"):
            st.markdown("""
            - "Analise este dataset e me d√™ insights"
            - "Crie gr√°ficos para visualizar os dados"
            - "Qual √© a correla√ß√£o entre as vari√°veis?"
            - "Identifique outliers nos dados"
            - "Processe esta planilha Excel"
            - "Compare dados entre abas da planilha"
            """)
        
        with st.expander("ÔøΩ An√°lise de Documentos (PDF)"):
            st.markdown("""
            - "Extraia as informa√ß√µes principais deste PDF"
            - "Fa√ßa um resumo do documento"
            - "Identifique dados e m√©tricas no texto"
            - "Analise contratos e documentos legais"
            - "Extraia tabelas e dados estruturados"
            """)
        
        with st.expander("ÔøΩüí∞ An√°lise Financeira"):
            st.markdown("""
            - "Como est√° o pre√ßo da a√ß√£o PETR4?"
            - "Analise o mercado de criptomoedas"
            - "Compare IBOVESPA com S&P 500"
            - "Tend√™ncias do mercado financeiro"
            """)
        
        with st.expander("üåê Pesquisa Web"):
            st.markdown("""
            - "Pesquise sobre intelig√™ncia artificial"
            - "√öltimas not√≠cias sobre tecnologia"
            - "Informa√ß√µes sobre empresa X"
            """)
        
        with st.expander("üíª An√°lise de C√≥digo"):
            st.markdown("""
            - "Revise este c√≥digo Python"
            - "Como melhorar a performance?"
            - "Identifique bugs no c√≥digo"
            """)
        
        with st.expander("üìã Tipos de Arquivo Suportados"):
            st.markdown("""
            - **üìä CSV**: Dados tabulares para an√°lise estat√≠stica
            - **üìÑ PDF**: Documentos para extra√ß√£o de texto e dados
            - **üìà Excel (XLS/XLSX)**: Planilhas com m√∫ltiplas abas
            - **Tamanho m√°ximo**: 30KB para CSV, sem limite para PDF/Excel
            """)
        
        return True

def render_chat():
    """Renderiza √°rea de chat principal"""
    st.title("üí¨ Chat com Agno Teams")
    
    # Verificar se tem team selecionado
    if not st.session_state.selected_team_id:
        st.error("‚ö†Ô∏è Nenhum team selecionado. Configure na sidebar.")
        return
    
    # Container para mensagens
    chat_container = st.container()
    
    with chat_container:
        # Exibe mensagens do hist√≥rico
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                if message["role"] == "user":
                    st.markdown(message["content"])
                    # Mostra indica√ß√£o se arquivo foi anexado
                    if message.get("has_file"):
                        file_type = message.get("file_type", "arquivo")
                        if file_type == "csv":
                            st.caption("üìä CSV anexado")
                        elif file_type == "pdf":
                            st.caption("ÔøΩ PDF anexado")
                        elif file_type in ["xls", "xlsx"]:
                            st.caption("üìà Excel anexado")
                        else:
                            st.caption("ÔøΩüìé Arquivo anexado")
                else:
                    # Mensagem do assistente
                    content = message["content"]
                    
                    # Se a resposta cont√©m c√≥digo, exibir em bloco de c√≥digo
                    if "```" in content:
                        st.markdown(content)
                    else:
                        st.write(content)
    
    # Input de mensagem
    if prompt := st.chat_input("Digite sua mensagem para os agentes..."):
        # Detectar tipo de arquivo anexado
        file_type = None
        if st.session_state.uploaded_file_data:
            try:
                import json
                file_data = json.loads(st.session_state.uploaded_file_data)
                file_type = file_data.get('type', 'arquivo')
            except:
                file_type = 'csv'  # Fallback para uploads antigos
        
        # Adiciona mensagem do usu√°rio
        user_message = {
            "role": "user", 
            "content": prompt,
            "has_file": st.session_state.uploaded_file_data is not None,
            "file_type": file_type
        }
        st.session_state.messages.append(user_message)
        
        # Exibe mensagem do usu√°rio
        with st.chat_message("user"):
            st.markdown(prompt)
            if st.session_state.uploaded_file_data:
                if file_type == "csv":
                    st.caption("üìä CSV anexado")
                elif file_type == "pdf":
                    st.caption("üìÑ PDF anexado")
                elif file_type in ["xls", "xlsx"]:
                    st.caption("üìà Excel anexado")
                else:
                    st.caption("üìé Arquivo anexado")
        
        # Processa resposta do backend
        with st.chat_message("assistant"):
            with st.spinner("ü§î Os agentes est√£o analisando..."):
                # Envia para o team selecionado
                response = send_message_to_team(
                    message=prompt,
                    team_id=st.session_state.selected_team_id,
                    file_content=st.session_state.uploaded_file_data
                )
                
                if "error" in response:
                    st.error(f"‚ùå {response['error']}")
                    content = f"Erro: {response['error']}"
                else:
                    # Processa resposta bem-sucedida
                    content = response.get("response", response.get("message", "Resposta processada"))
                    
                    # Exibe resposta
                    if "```" in content:
                        st.markdown(content)
                    else:
                        st.write(content)
        
        # Salva resposta no hist√≥rico
        st.session_state.messages.append({
            "role": "assistant", 
            "content": content
        })

def main():
    """Fun√ß√£o principal"""
    init_session_state()
    
    # Renderiza sidebar e verifica backend
    if render_sidebar():
        # S√≥ renderiza o chat se o backend estiver online e team selecionado
        render_chat()
    else:
        # Backend offline - mostra instru√ß√µes
        st.error("üö´ Backend n√£o est√° rodando")
        st.markdown("""
        ### Como iniciar o sistema:
        
        1. **Em um terminal**, execute o backend:
        ```bash
        cd /home/diego/Documentos/RA/play
        python agno_teams_playground.py
        ```
        
        2. **Em outro terminal**, execute este frontend:
        ```bash
        streamlit run streamlit_frontend.py
        ```
        
        3. **Acesse**: http://localhost:8501
        """)
    
    # Footer
    st.markdown("---")
    st.markdown(
        """
        <div style='text-align: center; color: #666; font-size: 0.8em;'>
            üß† Agno Teams Frontend - Powered by 
            <a href='https://docs.agno.com' target='_blank'>Agno Framework</a> + 
            <a href='https://streamlit.io' target='_blank'>Streamlit</a>
        </div>
        """, 
        unsafe_allow_html=True
    )

if __name__ == "__main__":
    main()
